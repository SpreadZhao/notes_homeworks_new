---
title: jni入门
description: 第一次进行JNI开发。也就是写个Hello World。但是，这里的坑实在是太多了。网上的教程绝大多数都是基于JDK1.8的，然而我是jdk17；另外就是Windows Terminal对于命令解析的改动，使得原来很多的命令现在不好使了。
links:
  - https://juejin.cn/post/7125338583959306248
  - https://www.baeldung.com/jni
---

# JNI Hello World

## 1 Java侧

初次进行JNI开发，要准备一个Java文件和C++/C的文件。首先从Java开始，就是创建了一个类，里面有个native函数，然后在main函数里调用这个函数：

```java
class HelloClass {
	static {
		System.loadLibrary("hello_native_lib");
	}
	
	private native void sayHello();
	
	public static void main(String[] args) {
		new HelloClass().sayHello();
	}
}
```

现在你可能回疑惑，这个sayHello()方法我们还没实现，那在哪里实现呢？既然是个native函数，那肯定实现的就是c系语言呀！所以先别急，现在这个类肯定是运行不了的。

另一个要注意的就是静态块里的内容。在程序运行之前，静态块里的内容就会执行。也就是加载了一个动态库，名字叫做hello_native_lib，显然这个库也是不存在的，我们稍后要创建。现在其实就可以说，**这个静态库里面，就包括着sayHello方法的具体实现**。

那么问题来了，如何写C的那部分东西呢？作为小白，我们是不知道JNI开发的具体标准的。**好在jdk给我们提供了一套标准**，只要给他一个java文件，它能自动帮你把对应的c语言的语法给弄出来，也就是.h文件。有了.h文件，对应的方法的名字命名规范，要传入的一些<u>默认参数</u>，就不用我们自己操心了。

```ad-question
你可能会问，这里的默认参数是什么玩意儿。你用膝盖想一想，Java怎么可能平白无故和C语言沟通？如果没有先人指定一套底层的标准，那不全乱了？所以这正是JNI的核心，在沟通的时候，会有一些默认参数，它们包括运行的环境，一些对象的指针等等。因为Java和C在语言规范上有很大的不同（比如Java就没有指针，C就没有类，虽然C++有），所以这些通用的变量就是为了让这些复杂且不统一的信息用统一的通道相互传递。
```

## 2 生成.h文件

下面就来操作吧，非常简单。但是，如果你之前在网上搜过，比如这样的文章：

* [JNI简介 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/349928909)
* [JNI 入门教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/jni-getting-started-tutorials.html)（这tm根本不是入门教程，谁上来就会用vs啊？？？）
* [Java Native Interface(JNI)从零开始详细教程-CSDN博客](https://blog.csdn.net/createchance/article/details/53783490)
* ……

还有一些我就不列了，太多了，而且都是抄的。这些文章都是基于jdk10以前，所以绝大多数都用的是1.8。里面确实有javah这个程序能够编译。但是在jdk10以后这个东西就去掉了：

[NDK开发遇到的三个错误：'javah' 不是内部或外部命令，编码GBK的不可映射字符， 程序包XX.XX不存在_javah' 不是内部或外部命令,也不是可运行的程序-CSDN博客](https://blog.csdn.net/nishigesb123/article/details/90024821)

所以，应该执行的是这个：

```shell
# On Windows
javac -h . .\HelloClass.java
```

javac的帮助文档里是这样写的：

```
javac <options> <source files>
where possible options include:
  -h <directory>
        Specify where to place generated native header files
```

也就是`-h .`表示将生成的.h文件放在当前目录下，最后加上源文件，也就是HelloClass.java。所以，执行完毕之后，我们能在当前文件找到它：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021163416.png]]

然后，我们可以看看这个.h文件，看看它都帮我们做了什么工作：

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloClass */

#ifndef _Included_HelloClass
#define _Included_HelloClass
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     HelloClass
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloClass_sayHello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

首先引入了一个jni.h，这个是jdk给我们提供的交互接口：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021163640.png]]

然后就是这个native函数的声明了，我们摘出来看看：

```cpp
JNIEXPORT void JNICALL Java_HelloClass_sayHello(JNIEnv *, jobject);
```

这里我们要注意一下，我是直接在工程里建的java文件。一般情况下，通常都是在包里面的，比如`com.spreadzhao.jni`包下面才是这个HelloClass.java。此时，自动生成的函数的名称为：

```
Java_com_spreadzhao_jni_HelloClass_sayHello
```

也就是以Java开头，后面跟上`包名+类名+方法名`，中间用下划线分割。

然后，这个函数有两个参数。我们Java的sayHello()方法里并没有这两个参数，而这两个参数就是刚才说的默认参数。关于参数，以及前面JNIEXPORT, JNICALL的作用，下面的文章都有介绍：

[NDK 系列（5）：JNI 从入门到实践，万字爆肝详解！ - 掘金 (juejin.cn)](https://juejin.cn/post/7125338583959306248)

显然，我们的任务就是实现这个函数了，也就是写点c++呗！其实写c也行，但是还是c++用的多一点。

## 3 实现c++函数

在同目录新建HelloClass.cpp文件：

```cpp
#include <iostream>
#include "HelloClass.h"

JNIEXPORT void JNICALL Java_HelloClass_sayHello(JNIEnv * env, jobject obj) {
	std::cout << "Hello from C++!" << std::endl;
}
```

完全按照.h文件告诉我们的来，所以没什么难度。

## 4 编译和汇编

通常，有了.h，有了.cpp，下一步不就是用g++编译吗？然而现在不是的。因为我们只是需要一个库，让java文件能够调用，所以我们要编译的可不是可执行文件，而是动态链接库。在Windows中是.dll，在linux中是.so。

```shell
g++ -c -I "%JAVA_HOME%\include" -I "%\JAVA_HOME%\include\win32" HelloClass.cpp -o HelloClass.o
```

我们先分析一下这个命令。-c选项表示编译和汇编，但不链接：

```
-c           Compile and assemble, but do not link.
```

```ad-note
编译、汇编、链接可以看[[Study Log/linux|linux]]
```

然后-I表示从哪里搜索你写的`#include`，因为我们的`jni.h`在jdk中而不在c标准库里，所以要这样加上去。

```
  -I DIR  add DIR to search list for .include directives
```

最后就是标准的编译过程，左边是输入，右边是输出，中间加上-o。看起来没啥问题，但是：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021170148.png]]

说找不到jni.h文件。我试了试把路径放在资源管理器上，是能找到的：

![[Study Log/java_kotlin_study/resources/Obsidian_OhhQqrXxu3.gif]]

包括我找的参考资料里让我这么写：

```shell
g++ -c -I%JAVA_HOME%\include -I%JAVA_HOME%\include\win32 com_baeldung_jni_HelloWorldJNI.cpp -o com_baeldung_jni_HelloWorldJNI.o
```

最后的结局都一样，找不到。我也不知道到底是哪里出了问题。后来我把环境变量去掉，换成真实的路径：

```shell
g++ -c -I 'D:\libs\jdk\jdk17\include' -I 'D:\libs\jdk\jdk17\include\win32' HelloClass.cpp -o HelloClass.o
```

这下就成功了。为什么读不了环境变量，我也不知道。这下，目录里就能看到新出现的.o文件了：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021170855.png]]

## 5 生成动态链接库

还记得我们一开始引入的hello_native_lib吗？它还没出现过呢！现在就是生成它的时候了。使用c++ object file（也就是那个.o文件）就能生成动态链接库文件，命令如下：

```shell
g++ -shared -o hello_native_lib.dll HelloClass.o -Wl,--add-stdcall-alias
```

这个`stdcall`是windows的调用标准。在其它平台生成动态链接库时，没有这个操作。

上面的命令也是我从参考网站中抄出来的，毫无疑问，又翻车了...

![[Study Log/java_kotlin_study/resources/Pasted image 20231021171621.png]]

这个问题我看到了这个网站：[gcc Wl option error · Issue #10314 · PowerShell/PowerShell · GitHub](https://github.com/PowerShell/PowerShell/issues/10314)

所以还是用单引号或者双引号括起来：

```shell
g++ -shared -o hello_native_lib.dll HelloClass.o "-Wl,--add-stdcall-alias"
```

这下就成功编译了，生成的dll文件就在当前目录下：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021171839.png]]

## 6 JNI，启动！

最后一步当然就是运行了。让java知道我们引入了一个新的动态链接库，这样在Java那个静态代码块加载的时候才不会报错：

```shell
java -cp . -Djava.library.path=. .\HelloClass.java
```

其中，这个`-Djava.library.path`就是动态链接库配置的选项，配置在当前目录，因为dll就在当前目录。显然，又出错了：

![[Study Log/java_kotlin_study/resources/Pasted image 20231021172527.png]]

经过前几次的教训，我立刻加上了引号：

```shell
java -cp . "-Djava.library.path=." .\HelloClass.java
```

![[Study Log/java_kotlin_study/resources/Pasted image 20231021172559.png]]

成功！这可是c++的函数而不是java的哟，这种体验还是很不一样的，~~有种NTR的美~~。

```ad-note
另外，这里说一下基本功，也就是java后面加上.java和加上.class有啥区别。

一开始我不是执行了`javac -h`吗，那个时候会同步编译出一个class文件。这个时候，其实我们也可以这样操作：

~~~shell
java -cp . "-Djava.library.path=." .\HelloClass
~~~

这就代表会从HelloClass.class中搜素HelloClass这个类。而如果加的是.java文件，那么就会重新给你编译一遍。
```

# 参考文档

我找到的唯一一个比较靠谱的文档，还是个国外的：[Guide to JNI (Java Native Interface) | Baeldung](https://www.baeldung.com/jni)

然而这个文档也不是很靠谱，比如哪些引号的问题，我搜了好久，问了gpt，最后还是自己试出来的。