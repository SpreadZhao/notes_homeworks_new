---
title: 3.5 锁的内存语义
chapter: "3"
order: "8"
---

## 3.5 锁的内存语义

### 3.5.1 锁的释放和锁的获取

锁这块，其实不用多说。从语义上讲，**他和volatile是一模一样的**！这可能会让你感到惊讶：明明锁能做到volatile做不到的事情，它俩的内存语义还一样？然而，事实就是如此。

```java
class MonitorExample {
	int a = 0;
	
	public synchronized void writer() {  // 1
		a++;                             // 2
	}                                    // 3
	
	public synchronized void reader() {  // 4
		int i = a;                       // 5
		……
	}                                    // 6
}
```

还是假设先执行writer，然后再执行reader。这样我们就能保证2 happens-before 5。这个很好理解。但是，书上用了非常多的篇幅来推导出这个过程。为啥呢？主要的点就在于，从这干干巴巴的代码里，**我们看不出来锁的获取和锁的释放**的过程。

在上面的代码中，操作1和操作4就是锁的获取；而操作3和操作6就是锁的释放。而锁能保证，对于一个锁的释放，这里面所作的所有修改都会对下一个线程可见。而这里的方式和volatile是一模一样的：**刷新到主存中，下一个线程让本地内存无效，从主存中读**。

现在，如果A释放了锁，那么过程就是这样的：

![[Study Log/java_kotlin_study/concurrency_art/resources/Pasted image 20231130000607.png]]

这和[[Study Log/java_kotlin_study/concurrency_art/resources/Drawing 2023-11-19 17.12.19.excalidraw.png|volatile的那个图]]一模一样不是吗？那么我们需要思考一下：凭啥他能一样？之前我们说，这个图实际上是两个syncronized的版本，但是在假设writer()先于reader()执行时，这个图对于volatile也是对的。

> [!stickies] 
> 这里好好想想，“大大滴写”指得到底是什么？

volatile只是对读和写进行了原子操作。而这里我们虽然用了锁，但锁里的代码**从外部看**，也只是读和写。对于writer()方法，我们不关心它的实现，只知道它写了a，但是因为用锁修饰了，所以是一个**大大滴写**。而volatile只能原子化普通的写，不能原子化这个**大大滴写**。所以，**当volatile只操作一个变量的读写时，锁只操作一个变量的读写时，它们的效果是等价的，否则，锁>volatile**。比如在本例中，`a++`属于大大滴写，因为涉及临时变量，所以锁能做到，而volatile做不到，但是在volatile也能做到的情况下，它们俩是等价的。

现在可以直接总结锁的内存语义了，其实和volatile一模一样。当锁释放的时候，代表这个线程说：“==我搞定了！共享变量你们用吧！==”这就像在对volatile写的时候，写完了，也可以告诉其它线程“==我写完了，你们读吧==！”一样。所以：

```ad-def
title: 锁的内存语义

* 线程 A 释放一个锁，实质上是线程 A 向接下来将要获取这个锁的某个线程发出了（线程 A 对共享变量所做修改的）消息。
* 线程 B 获取一个锁，实质上是线程 B 接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。
* 线程 A 释放锁，随后线程 B 获取这个锁，这个过程实质上是线程 A 通过主内存向线程 B 发送消息。
```
