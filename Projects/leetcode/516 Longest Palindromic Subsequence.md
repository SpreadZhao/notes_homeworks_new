---
num: "516"
title: "Longest Palindromic Subsequence"
link: "https://leetcode.cn/problems/longest-palindromic-subsequence/description/"
tags:
  - leetcode/difficulty/medium
---
这道题算是很经典了。虽然我再想还是没想出来。。。

> 我tm感觉我现在的算法就是一坨狗屎。

这道题的目的是最长回文子**序列**，不是子串。在说字串的时候，我们会着重看两个东西的不同。

序列的意思是，只要包含字母的一部分，就算是子序列，**不必须是连续的**。比如：

```
abcdef
```

的子序列可以是：

```
a
b
c
ad
ae
af
...
```

那可太多了对吧。其实根本思想是一棵树：**对于这个父串的每一个字母，我都可以选择要或者不要**。所以这个画出来是一个超大的树：

![[Projects/leetcode/resources/Drawing 2024-09-06 23.12.21.excalidraw.svg]]

> 我只画了`abc`的，`abcdef`的那棵树实在是太大了。

可以看到，每个字母可以要也可以不要。所以如果是3个字母，结果就是$2^3 = 8$种情况。所以这本质就是一种递归。

解释完了序列，现在来看这个问题，最长回文子序列。显然，回文，正着和反着相同，也就是两个相同的字母夹心，夹的心的两边又是两个相同的字母，以此类推。。。

但是以上的描述是回文串而不是回文序列。所以回文序列的判断要有些不同。我们来讨论一下：如果==我们已经知道==了一个串的最长回文子序列的长度是n。那么，如果我们在这个串的左右两边加上两个相同的字母：

![[Projects/leetcode/resources/Drawing 2024-09-06 23.25.00.excalidraw.svg]]

那么，其实显而易见，新生成的串的最长回文子序列的长度**一定是**n + 2。**因为如果只包含一个字母，那顶天也只能是n + 1**。

> [!comment] 我们已经知道
> 注意这里的“我们已经知道”。这代表着：我们已经完全确定了中间这个串的最长子序列的长度，它就是一个具体的答案，不会改变。也就是我们计算过。我们咋计算的？当然是基本情况+状态转移方程不断递推的。比如1个字母，那答案肯定是1；2个字母，那答案要么是1要么是2，就看这两个字母是否相等；如果是3个字母，就需要按照上图中的情况去讨论了。后面我们会更加详细地进行解释。

而如果这两个字母不相等：

![[Projects/leetcode/resources/Drawing 2024-09-06 23.28.13.excalidraw.svg]]

那么结果是什么？有可能是n吗？有可能。有可能比n大吗？也有可能。准确的来说，它应该是以下两种情况的最大值：

- 左边字母+中间构成的串的最长回文子序列长度；
- 右边字母+中间构成的串的最长回文子序列长度。

图示如下：

![[Projects/leetcode/resources/Drawing 2024-09-06 23.31.57.excalidraw.svg]]

因为两个candidate都一定包含了中间的n，所以不需要再和n比较了。

到了这里，其实我就有一个非常重要的问题：**已知**。中间串的最长回文子序列的长度是n，这是我们已知的。***但是我们凭什么会知道candidate 1和candidate 2的值呢？这两个字母不是新添加的吗***？

这就是这道题最难懂的一个点。我大部分时间也是卡在了想这个地方。答案是：如果我们能保证迭代的方向，串从短变长，我们就能保证在遍历到这里时，candidate 1和candidate 2是已知的。

我们用题例的第二个`cbbd`来说明这一点。

![[Projects/leetcode/resources/Drawing 2024-09-06 23.36.49.excalidraw.svg]]

假设我们遍历到了这里，此时`i == 0`，`j == 2`。我们希望计算`dp[0][2]`的值。但是我们发现，此时`s[0] != s[2]`。所以，需要在c1和c2中选一个最大值。但是，我们怎么知道c1的值是1，c2的值是2的呢？

我们可以利用i和j的遍历方向来保证这一点。我们让：

- j从0遍历到最后；
- 每次遍历到j的一个值，i都从j - 1遍历到0

![[Projects/leetcode/resources/Drawing 2024-09-06 23.43.49.excalidraw.svg]]

看一下上面这张图。太巧了吧也！我们在算`dp[0][2]`的时候，需要从`dp[0][1]`和`dp[1][2]`里取一个最大值。但是就是这么巧，==这俩值我们在历史的遍历中都算出来了==！是巧合吗？当然不是，是有迹可循的：我们仔细观察就会发现，我们比较的这两个值，c1和c2，本身就来自于两个历史：

- c1，也就是本例中的`dp[0][1]`，来自于**之前j的循环**。因为j是从1 - 最后，所以当j=k的时候，j=k-1的循环一定已经完毕，那么我们其实就能保证对于任意一个j左侧的i，`dp[i][j - 1]`的值就一定是我们已经算过的值；
- c2，也就是本例中的`dp[1][2]`，来自于**本轮j的循环**。因为i是从j-1到0，所以当i=k的时候，i=k+1的循环一定已经完毕。那么我们其实就能保证对于任意一个j左侧的i，`dp[i + 1][j]`的值就一定是我们已经算过的值。

> [!comment] 这俩值我们在历史的遍历中都算出来了
> 你可能会问上面图中的`dp[0][1]`和`dp[1][2]`究竟是咋算出来的。其实还是动态规划本身的基石：1个字母，那答案肯定是1；如果是2个字母，那就看这两个字母是否相等。如果相等，那答案肯定是2；如果不是，那答案肯定是1。字符串由短变长，所以当我们算长的情况的时候，比它短的的情况我们一定已经都计算过了。

就是这样的迭代顺序，保证了我们能利用好已经计算的结果，去推断新的结果。总结一下整体思路：

- j从1到最后；
	- 对于每一个j，i从j-1到0；
		- 判断i和j指向的字母是否相等：
			- 如果相等，那么i和j区间内的串的最长子序列长度就是夹心的长度+2；
			- 如果不相等，那么。。。的最长子序列的长度就是以下二者的最大值：
				- 只包含i指向字母+中间的串；
				- 只包含j指向字母+中间的串。

除此之外，还有一些基本情况要考虑：

- `dp[i][i]`的值一定是1，因为只有1个字母；
- 如果i和j的差值是1，那么如果两个字母相等，答案是2；否则就是1。因为只有2个字母；
- 只有差值是2及以上的时候，i和j中间才能夹心（夹至少一个字母），才能完美适配上面的规则。

总的来看，这道题最难的地方其实不是找到类似夹心+2的规律，也不是找到二者最大值的规律。而是**如何找到一个迭代的方向**。本题用的是动态规划的思想，而动态规划的核心思想就是：利用已经算出来的结果，加上**简单的逻辑**（状态转移方程），推断新的结果。而这道题如果我们迭代的方向出现了错误，那么就无法好好地利用计算出来的结果。在处理其他动态规划的问题时，这个要点永远是最重要的，比动态规划的那个~~通用的规则~~**状态转移方程**要重要的多。

好了，上代码：

```cpp
int Solution::longestPalindromeSubseq(string s) {
    int dp[s.size()][s.size()];
    for (int i = 0; i < s.size(); i++) {
        dp[i][i] = 1;
    }
    for (int j = 1; j < s.size(); j++) {
        for (int i = j - 1; i >= 0; i--) {
            if (j - i < 2) {
	            // 小于2，我们可以简单处理。它们就是dp的基石
                dp[i][j] = s[i] == s[j] ? 2 : 1;
            } else {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
    }
    return dp[0][s.size() - 1];
}
```