---
num: "1639"
title: "Number of Ways to Form a Target String Given a Dictionary"
link: "https://leetcode.cn/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/"
tags:
  - leetcode/difficulty/hard
---
- [x] #TODO tasktodo1723829928335 这个巨jb难的动态规划。 🆔 qwwy4p 🔺 ➕ 2024-08-17 ✅ 2024-08-18

为了用c++整这道题，真把我差点弄死。你妈的。

首先，我们还是希望你能读懂题。所以我先把题目翻译成人话。

它会给你一个`vector<string>`，也就是好几个字符串。这里保证，**每个字符串的长度都是一样的**。比如：

```cpp
"acca"
"bbbb"
"caca"
```

这个`vector<string>`就是题目中说的Dictionary。我们的目的就是用这个**字典里的字符**去生成另一个字符串target。这里我直接说结论，我们要做的，就是在**每一列里挑一个字母**，当然每一列我**可以挑也可以不挑**。比如我要生成`aba`，那么就可以：

![[Projects/leetcode/resources/Drawing 2024-08-18 14.09.52.excalidraw.svg]]

这里我随便列出来了三种。当然按照描述，一共可以有6种。那么现在，这里的问题可以总结成个：

1. 每一列我可以挑，也可以不挑；
2. 如果我挑了，那么我要在这个列里找出我当前需要的字母。

其实看到这里，我们已经发现动态规划的味道了。当然，我们还是要了解一下动态规划的思想：

- 自底向上解决问题（和暴力递归相反）
- 要尝试每一种可能
- 在动态规划不断归的过程中，问题的规模不断变大

那么现在的问题是，如何确定问题的规模。我们要做的是，用**几列字母，生成一个字符串**。那其实在不断归的过程中，就应该是：

**用所给的字典的前几列，生成字符串的前几个字母**。

另外，动态规划的起始条件应该是要直接给出的。这里其实就是：如果我们用0列，生成target的前0个字母，有几种方法？答案是1种。也就是什么都不做。因此，`dp[0][0] = 1`。

> [!attention]
> 这里，我们认为：`dp[i][j]`表示，用前`j`列，生成target的前`i`个字母。
> 
> - [ ] #TODO tasktodo1723967648163 为什么不是用前i列生成前j个字母？反过来有什么问题吗？ ➕ 2024-08-18 🔽 🆔 ylokdt

类似地，我们也能给出`dp[i][0]`的结果。它表示我用前0列生成前i个字母。因此，如果`i > 0`的话，这里的值一定都是0。因为我什么都没有，你却要我生成东西，那显然是做不到的。

下一个问题，是这个dp数组的大小。也就是**确定问题的规模的变化**。首先，我要生成的target的规模，是从前0个字母，到整个target。如果target的长度是`m`的话，那么问题的规模的变化就是$[0, m]$。因此，这里需要讨论的情况有$m + 1$种，也就是dp数组的行数就是`m + 1`。

然后是列数。也就是从使用0列，到使用整个字典里的所有列。假设字典里的每个字符串长度是`k`的话，问题规模的变化就是$[0, k]$，同理，可以得到dp的列数应该是`k + 1`。

由此，我们得到了dp数组：

```cpp
// (m + 1) * (k + 1)
vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));
```

> [!attention]
> `j`是横向，`i`是竖向。

目前，我们有了动态规划里第一列的值，也就是初始情况。我们的目的就是得到dp的最后一个值`dp[m][k]`，它表示为了生成target的前m个字母，也就是target本身，使用k列，也就是字典里所有列的情况下，有多少种方法。

> [!attention]
> 本题的核心思想可以直接看[[#^e1a5b2]]

结合我们之前说过的结论：

> 1. 每一列我可以挑，也可以不挑；
> 2. 如果我挑了，那么我要在这个列里找出我当前需要的字母。

我们可以知道，如果我们已经知道了`dp[i][j]`的值（它表示我用前j列生成前i个字母），代表着我已经考虑了前j列。那么接下来我要挑j + 1列了：

1. 如果我不挑j+1列，==就是用j+1列去生成前i个字母==，也就是`dp[i][j + 1]`的值；
2. 我挑了j+1列，==去生成前i+1个字母==，也就是`dp[i + 1][j + 1]`的值。

> [!comment] 就是用j+1列去生成前i个字母 | 去生成前i+1个字母
> 这里你可能会感觉很奇怪，是不是少了几个组合。比如在不挑j+1列的时候，为什么不算生成前i+1个字母；还有挑j+1列的时候，为什么不算生成前i个字母。答案是没有必要。可以看后面的[[#^e1a5b2|核心思想]]。因为我们只需要这两部分数据就能得到所有的方法了。

如果我们已经考虑了前`j`列的情况下，生成target的前`i`个字母有`y`种方法。那么我们能知道下面的情况：

- 如果我用比`j`还多的列去生成前`i`个字母，那么至少也是有`y`种方法。
- 如果我用`j + 1`列去生成前`i`个字母，但是我没考虑第`j + i`列，那么最后的方法还是`y`种。也就是`dp[i][j + 1] = dp[i][j]`；
- 如果我用`j + 1`列去生成前`i + 1`个字母，并且我考虑了`j + 1`列，那么最后的方法应该是`y * count`种，其中`count`为第`i + 1`个字母在`j + 1`列出现的次数。也就是`dp[i + 1][j + 1] = dp[i][j] * count`。

我们用真实的例子来走一遍。下面是初始情况：

![[Projects/leetcode/resources/Drawing 2024-08-18 16.35.20.excalidraw.svg]]

接下来，我们逐个进行计算。这里的方向是外层循环是i，内层循环是j。已知`dp[0][0] == 1`，接下来算的就是`dp[0][1]`和`dp[1][1]`。

> [!question] 为什么循环方向是先递增列数，再递增target的字母数？
> 我们这么想。如果我选了j列，最多能生成多少个字母？答案一定是j个。因为即使我每一列都挑，最多也就能挑出来j个字母。因此，如果我先递增字母数，有意义吗？假设`j == 1`，那么我还要让`i`从0遍历到3？当`i == 2 || i == 3`的时候，这个时候的计算有意义吗？肯定是没有。因为当`j == 1`的时候，我根本就选不出来更多的字母。
> 
> **每一次循环，我们是为了解决一个子问题：*使用从`0`列到`k`列，生成前`j`个字母有多少种方法*？而这样的子问题一共有`m + 1`个(j从0-m)**。本句话配上后面的[[#^e1a5b2|核心思想]]，其实就已经把这道题回答完了。剩下的流程就不重要了。

^4ac788

- 如果我没考虑第1列，但是还是要生成0个字符，那么结果应该还是1种。也就是`dp[0][1] = 1`；
- 如果我考虑了第1列，要生成1个字符，那么结果应该是1乘上a在**第一列**出现的次数，也就是1。所以`dp[1][1] = 1`。

![[Projects/leetcode/resources/Drawing 2024-08-18 16.59.59.excalidraw.svg]]

然后j增加，也就是我已经确定了`dp[0][1]`的最终值就是1。所以我现在要考虑的是第二列。

- 如果我没考虑第2列，但是还是要生成0个字符，那么结果应该还是1种。也就是`dp[0][2] = 1`；
- 如果我考虑了第2列，要生成1个字符，那么结果应该是1乘上a在**第二列**出现的次数，也就是1。所以`dp[1][2] = 1`。

![[Projects/leetcode/resources/Drawing 2024-08-18 17.06.06.excalidraw.svg]]

接下来看第三列：

- 如果我没考虑第3列，但是还是要生成0个字符，那么结果应该还是1种。也就是`dp[0][3] = 1`；
- 如果我考虑了第3列，要生成1个字符，那么结果应该是1乘上a在**第三列**出现的次数，也就是0。所以`dp[1][3] = 0`。

![[Projects/leetcode/resources/Drawing 2024-08-18 17.10.47.excalidraw.svg]]

最后第四列：

- 如果我没考虑第4列，但是还是要生成0个字符，那么结果应该还是1种。也就是`dp[0][4] = 1`；
- 如果我考虑了第4列，要生成1个字符，那么结果应该是1乘上a在**第四列**出现的次数，也就是2。所以`dp[1][4] = 2`。

![[Projects/leetcode/resources/Drawing 2024-08-18 17.12.47.excalidraw.svg]]

接下来来到第二行，也就是我要生成一个`a`了，但是我还会考虑更多的列，尝试生成`ab`。还是从考虑的列为1-4进行遍历。目前，我的已知是，如果我使用前0列，生成1个字符，一共的方法是0种。也就是`dp[1][0] == 0`。

- 如果我没考虑第1列，但是还是要生成1个字符，那么结果应该。。。是多少？这里出现问题了。按照我们之前的描述，应该是0。但是这里的情况是，`dp[1][1]`已经有值了。所以，实际情况应该是二者做一个累加。也就是`dp[i][j + 1] += dp[i][j]`。你可能会问为什么是累加2️而没有乘法关系。因为这两条路线得到的方法数量之间没有依赖关系。一个是从`dp[0][0]`，也就是为了生成`""`；而另一个是从`dp[1][0]`，也就是为了生成`"a"`。只有当列数增加的同时，我们要生成的字母数也增加时，这个时候才会和原来的方案有依赖关系。
- 如果我考虑了第1列，要生成2个字符，那么结果应该是**0**乘上a在**第一列**出现的次数，也就是0。所以`dp[2][1] = 0`。这也呼应了我们之前问过的[[#^4ac788|问题]]。这里我们只考虑了第一列，但是却要生成2个字符，显然结果是0种。因为根本选不出来。在后面的遍历中我们会逐渐发现，**dp数组中靠左下部分会都是0**，因为越靠近左下，代表我们要用更少的列生成更多的字母，那显然是做不到的。

![[Projects/leetcode/resources/Drawing 2024-08-18 17.34.43.excalidraw.svg]]

接下来考虑第二列：

- 如果我没考虑第2列，但是还是要生成1个字符，那么结果应该是累加起来。也就是`dp[1][2] = 2`。这两种方法里，第一种是：一开始多考虑第二列，多生成一个`"a"`的时候的方法，也就是a在第二列出现的次数；另一种是：我考虑了一列，生成一个`"a"`的方法是1种。所以它们两个加起来才是2种。其实，将这个翻译到一般情况，就是本题的核心思想：**如果我想知道使用`k`列生成`m`个字符有多少种方法，这个数据来源于两方面**： ^e1a5b2
	- 不挑第k列：**使用前`k - 1`列生成`m`个字符有多少种方法。这些方法我们可以直接搬过来；**
	- 挑第k列：**如果我用了第`k`列，那么我只需要知道生成前`m - 1`个字符有多少种方法，然后用它去乘以第`k`列中第`m`个字符的个数。就得到了另一部分方法。**
	- **这两部分完全不会有交集，并且它们的合就是等于我们要的答案。**
- 。。。

我们能发现，当我们通过`dp[i][j]`去算`dp[i + 1][j + 1]`的时候，其实是在提前准备数据。因为考虑前m个字母的时候，前m-1个字母的结果必须要准备好，这样才能用它去乘以新的列中的字母个数。

而对于直接照搬的方法，它们真正累加进来的时机会稍微晚一些。这是因为提前准备是我们会在m-1个字母的时候就超前考虑m个字母的情况，而对于列数的增加，是顺着我们dp循环的方向同步累加的。举个例子：

- 只有我知道了用0列生成`"a"`有多少种方法，我才能把它累加到用1列生成`"a"`的情况；
- 只有我知道了用1列生成`"a"`有多少种方法，我才能把它累加到用2列生成`"a"`的情况；
- 只有我知道了用2列生成`"a"`有多少种方法，我才能把它累加到用3列生成`"a"`的情况；
- 。。。

举个例子，最后的dp数组中，`dp[1][4]`的值应该是4。这来源于两部分：

- 提前算出来的：我已经知道了使用3列去生成`""`时有一种方法，所以我只需要看第4列里的`a`的个数是2，所以这部分答案是`1 * 2 = 2`；
- 累加出来的：我通过本轮迭代不断累加，发现使用3列去生成`"a"`就已经有2种方法了，所以这部分可以直接照搬过来。

参考：[Number of Ways to Form a Target String Given a Dictionary - LeetCode](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/editorial/)。

最后的代码：

```cpp
int Solution::numWays(vector<string> &words, string target) {
    constexpr int ALPHABET = 26;
    constexpr int MOD = 1e9 + 7;
    const size_t k = words[0].size();
    int columnToCount[ALPHABET][k];
    memset(columnToCount, 0, sizeof(columnToCount));

    for (int j = 0; j < k; ++j) {
        for (auto &str : words) {
            columnToCount[str[j] - 'a'][j]++;
        }
    }

    const size_t m = target.size();
    vector<vector<int>> dp(m + 1, vector<int>(k + 1, 0));
    dp[0][0] = 1;

    for (int i = 0; i <= m; i++) {
        for (int j = 0; j < k; j++) {
            if (i < m) {
                dp[i + 1][j + 1] = (dp[i + 1][j + 1] + static_cast<long long>(columnToCount[target[i] - 'a'][j]) * dp[i][j]) % MOD;
            }
            dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % MOD;
        }
    }

    return dp[m][k];
}
```

- [ ] #TODO tasktodo1723976087002 这道题延伸出来的溢出问题，还有打印二维数组的问题。 https://chatgpt.com/share/5ac6fe7f-73b7-48e3-8e52-91991717403e ➕ 2024-08-18 🔽 🆔 0ejpfo