---
num: "14"
title: "Longest Common Prefix"
link: "https://leetcode.cn/problems/longest-common-prefix/description/"
tags:
  - leetcode/difficulty/easy
---
这题太简单了，直接看解析，很好看懂：[14. 最长公共前缀 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-common-prefix/solutions/288575/zui-chang-gong-gong-qian-zhui-by-leetcode-solution/)

不过，题解里说的两种办法都是很常规的办法。一个是横向扫描，遍历每个字符串，每次遍历一个，更新出一个新的最长前缀。所以我们会看到，随着遍历，prefix的长度是越来越短的；第二种方法是纵向扫描。也就是先比较所有字符串的第一个字母，再比较第二个。。。最后等第一个不相等的出现，那么之前的那些就是最后的答案。

其实可以思路打开：既然所有的字符串都要包括这个前缀，我们只需要**找两个差距最大的字符串比较**就行了。那么差距最大这个怎么体现呢？想当然，会想到排序。

排序之后，我们取出第一个字符串，和最后一个字符串。**他俩的公共前缀，就是所有字符串的最长公共前缀**。

> [!error] Deprecated
> 后面都不用看，直接看结论：[[#^98fb75]]

不过，我们还是要证明一下我们的观点成立。我们这么想：如果我们随便拿两个字符串去找最长公共前缀，那么我们找到的前缀是可能找长了，还是找短了？答案是肯定的：**找长了**。因为所有字符串的最长公共前缀是所有字符串都有的，那这俩也肯定包括。所以**我们找出来的这个，只可能比我们要的答案，要长**。

```
faa
fab
faax
fac
```

上面的例子，如果我们随便选了1和3，那么结果是faa。但是真正的答案是fa，所以我们找长了。

既然我们找长了，那么就代表：我们随便找出来的这个公共前缀，它的一段屁股肯定是我们不需要的。比如上面faa里最后一个a，就是我们不需要的。

现在看看排序后的情况：

```
faa
faax
fab
fac
```

这样，我们会选出faa和fac。当我们比较a和c的时候，发现不一样，所以我们认为所有字符串的最长公共前缀是fa。那么这样为啥就没问题呢？

~~首先，我们没找长。因为现在是按照字典序排的。所以，如果我们一列一列地框，从第一列开始，一旦发现框里面的字母出现了不一样的，那么前面的~~

我突然发现，好像不用解释这么麻烦。就从上面题解里的第二种思路出发。我们一列一列框，出现了不一样的，那么之前那些就是最长公共前缀。在我们排序了的情况下，**只要出现了不一样，那么第一个和最后一个字符串一定是不一样的。因为是按字典序排的**。好，结束了。 ^98fb75