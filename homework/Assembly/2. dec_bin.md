```asm
data segment
    numtip db 'please enter a decimal number:$'
    inbuf db 100 dup('0')
    resln dw 0
    res db 100 dup('0')
    divnum dw 2
    errflowtip db 'Error, every ch must between 0 and 9.$'
ends

stack segment
    dw   128  dup(0)
ends

code segment
start:
; set segment registers:
    mov ax, data
    mov ds, ax
    mov es, ax
    
    mov ax, stack
    mov ss, ax
    mov sp, 50h
    
    
    ; our story start from here.    
    call doall;
    
    
    
    ; blocked
    mov ah, 01h
    int 21h
    
    
quit:    
    mov ax, 4c00h ; exit to operating system.
    int 21h
    
doall:
    ; please enter num    
    lea dx, numtip
    mov ah, 09h
    int 21h
    
    ; receive num as string
    mov ah, 0ah
    mov al, 0 
    lea dx, inbuf
    int 21h
    
    ; check your input
    call chkipt
    
    ; turn the string to a num
    call stn
    
    ; get binary and store it to buf(reverse)
    call gb
    
    ; show binary
    call newline
    call show
    call newline
    
    jmp doall
    
stn: ; string to number, number is in ax(decimal) 
    mov bx, 0
    mov ax, 0
    mov si, 2        
    mov cx, 0
    mov cl, inbuf + 1
    cal:
        mov bl, inbuf[si]
        ; ch - '0'
        sub bl, 30h
        add ax, bx
        mov bx, 10
        mul bx
        inc si
        loop cal
        
    mov bx, 10
    div bx
    
    ret
    
gb: ; get binary. result is in res, but reverse
    push ax
    push bx
    push dx

    mov bx, 2
    mov si, 0
    mov cx, 0
    caldiv:
        div divnum
        inc resln
        cmp ax, 0
        je last
        mov res[si], dl
        inc si
        mov dx, 0; must do it!!! reset div system
        jmp caldiv
        
    last:
        mov res[si], dl
    
    pop dx
    pop bx
    pop ax    
    
    ret
    
    
show:
    mov si, resln
    mov ah, 02h
    
    cshow:
    mov dl, res[si - 1]
    add dl, 30h
    int 21h
    dec si
    jz showend
    jmp cshow   
    
    
    showend:   
    ret
    
newline:
    ; \r\n
	mov dl, 0Dh
	mov ah,2
	int 21h
	mov dl, 0Ah
	mov ah, 2
	int 21h
	ret
	
chkipt: ; check your input
    ; you want to quit?
    cmp inbuf + 2, 'q'
    je quit
    cmp inbuf + 2, 'Q'
    je quit
    
    ; your input is wrong?
    mov si, 2
    mov cx, 0
    mov cl, inbuf + 1
    chkwr:
        cmp inbuf[si], '0'
        jb errflow
        cmp inbuf[si], '9'
        ja errflow
        inc si
        loop chkwr
    
    
    ret
    
errflow:
    call newline
    mov ah, 09h
    lea dx, errflowtip
    int 21h
    call newline
        
    jmp doall
        
ends

end start ; set entry point and stop the assembler.

```