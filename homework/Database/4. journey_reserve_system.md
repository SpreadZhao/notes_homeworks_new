# 1. 实验名称

第4次实验：旅行预定系统

# 2. 实验日期

2022年11月28日    宿舍

# 3. 实验学生

20009200303    赵传博

# 4. 实验目的

MySQL数据库的综合练习。

# 5. 实验内容

基于MySQL，设计并实现一个简单的旅行预订系统。该系统涉及的信息有航班、大巴班车、宾馆房间和客户数据等信息。其关系模式如下：

```sql
FLIGHTS (String flightNum, int price, int numSeats, int numAvail, String FromCity, String ArivCity);
HOTELS(String location, int price, int numRooms, int numAvail);
BUS(String location, int price, int numBus, int numAvail);
CUSTOMERS(String custName,custID);
RESERVATIONS(String custName, int resvType, String resvKey;
```

为简单起见，对所实现的应用系统作下列假设：

1. 在给定的一个班机上，所有的座位价格也一样；flightNum是表FLIGHTS的一个主码（primary key）。
2. 在同一个地方的所有的宾馆房间价格也一样；location是表HOTELS的一个主码。
3. 在同一个地方的所有大巴车价格一样；location是表 BUS的一个主码。
4. custName是表CUSTOMERS的一个主码。
5. 表RESERVATIONS包含着那些和客户预订的航班、大巴车或宾馆房间相应的条目，具体的说，resvType指出预订的类型（1为预订航班，2为预订宾馆房间，3为预订大巴车），而resvKey是表RESERVATIONS的一个主码。
6. 在表FLIGHTS中，numAvail表示指定航班上的还可以被预订的座位数。对于一个给定的航班（flightNum）,数据库一致性的条件之一是，表RESERVATIONS中所有预订该航班的条目数加上该航班的剩余座位数必须等于该航班上总的座位数。这个条件对于表BUS和表HOTELS同样适用。

**应用系统应完成如下基本功能：**

- [x] 航班，大巴车，宾馆房间和客户基础数据的入库，更新（表中的属性也可以根据你的需要添加）。
- [x] 预定航班，大巴车，宾馆房间。
- [ ] 查询航班，大巴车，宾馆房间，客户和预订信息。
- [x] 查询某个客户的旅行线路。
- [x] 检查预定线路的完整性。
- [x] 其他任意你愿意加上的功能。
- [ ] **通过高级程序语言（C/C++、Java，无限定）访问数据库，提供基本界面**

# 6. 实验过程和结果

## 6.1 用到的技术

* MySQL
* Spring boot
* Mybatis plus

数据库中Schema设计：

```sql
create table flights(
	flight_num char(10) primary key,
	price int,
	num_seats int,
	num_avail int,
	from_city varchar(20),
	ariv_city varchar(20)
);

create table hotels(
	location char(20) primary key,
	price int,
	num_rooms int,
	num_avail int
);

create table bus(
	location char(20) primary key,
	price int,
	num_seats int,
	num_avail int
);

create table customers(
	cust_name varchar(30) primary key
);

create table reservations(
	resv_key char(20) primary key,
	cust_name varchar(30),
	resv_type int,
	
	foreign key(cust_name) references customers(cust_name)
);
```

ER图：

![[homework/Database/resources/Pasted image 20221127171233.png]]

这里需要强调一点，就是reservations表。预定这张表是用户修改最频繁的表，比如某个用户定了一张机票，就要在这张表中添加一个tuple。但是，我怎么根据用户预定的产品类型去修改相应的表呢？也就是顶机票就要修改flights表；定巴士就要修改bus表等等……靠的就是reservations表中的resv_type。当检测到是某个值的时候，就根据这个值去自动修改对应的表即可。但是，知道了修改这张表，我又怎么去知道应该修改表中的哪一项呢？靠的就是resv_key。比如我预定了`3U8595`这趟航班，那resv_key就是`00013U8595`。前4位是固定长度的id，而后面就是预定的bus、flight、hotel的主键。通过这个主键就能唯一确定要修改的tuple。

接下来是服务端，使用Springboot + Mybatis plus实现。Springboot项目这里给出启动的日志：

![[Article/spring_start]]

然后是数据模型的定义。首先给出总体的架构：

![[homework/Database/resources/Pasted image 20221128220358.png]]

response包下为和网络请求相关的；dao包下为数据库查到的东西对应的对象。以航班为例，就是这样的形式：

```java
@TableName("flights")  
@Data  
public class Flight {  
    @TableId  
    private String flightNum;  
    private int price;  
    private int numSeats;  
    private int numAvail;  
    private String fromCity;  
    private String arivCity;  
}
```

> `@TableName`注解用来和数据库的表名相关联；`@Data`是lombok注解，能自动生成构造和getter and setter。`@TableId`是主键注解，表示这个属性是主键。注意，在数据库中的`num_seats`这种下划线格式会自动匹配成java中的`numSeats`这种驼峰形式。

response包中的东西和网络相关，我们在写Controller的时候随用随介绍即可。下面我们就来介绍Springboot项目中最重要的Controller。

Controller中用来处理客户端发送的各种http请求，因此这里就需要有对应的dao实例：

```java
@RestController  
public class Controller {  
    @Autowired  
    HotelMapper hotelMapper;  
    @Autowired  
    ReservationMapper reservationMapper;  
    @Autowired  
    FlightMapper flightMapper;  
    @Autowired  
    BusMapper busMapper;
	
	... ...
}
```

> `@Autowired`表示自动装填，表明这是个Bean，对应的对象不用自己new，由Spring boot的IOC类去构造。

这里的Mapper都是什么呢？其实就是Mybatis plus中的dao实现。它们都是接口，拿航班来举例子，只需要这样写：

```java
@Mapper  
public interface FlightMapper extends BaseMapper<Flight> {  
}
```

这就完成了！由于泛型中传递的是Flight，而Flight正好关联了表flights，因此Mybatis plus根据这些信息就能将程序和数据库建立起链接。

首先，我们先小测试一手，从hotels表中`select * from hotels`。使用Mybatis plus执行这个非常简单，就一句话：

```java
hotelMapper.selectList(null)
```

该函数返回的对象正是一个`List<Hotel>`类型。但是我们http请求中返回的对象通常是单个的Response，所有的数据都要添加到其中。所以我们先来看看测试方法的返回值TestResponse：

```java
public class TestResponse extends Response{  
  
    private List<Hotel> list = new ArrayList<>();  
  
    public TestResponse(boolean status, String op, String msg) {  
        super(status, op, msg);  
    }  
  
    public void absorbRes(List<Hotel> ls){  
        list.addAll(ls);  
    }  
  
    public List<Hotel> getList() {  
        return list;  
    }  
  
    public void setList(List<Hotel> list) {  
        this.list = list;  
    } 
} 
```

这个类继承自Response，所有响应的父类：

```java
public abstract class Response {  
    private boolean status;  
    private String op;  
    private String msg;  
  
    public Response(boolean status, String op, String msg) {  
        this.status = status;  
        this.op = op;  
        this.msg = msg;  
    }  
  
    public boolean isStatus() {  
        return status;  
    }  
  
    public void setStatus(boolean status) {  
        this.status = status;  
    }  
  
    public String getOp() {  
        return op;  
    }  
  
    public void setOp(String op) {  
        this.op = op;  
    }  
  
    public String getMsg() {  
        return msg;  
    }  
  
    public void setMsg(String msg) {  
        this.msg = msg;  
    }  
}
```

很容易理解，唯一注意的就是TestResponse中的absorbRes方法，它将参数中的所有添加到自己的List中。接下来就展示我们的测试方法：

```java
@RestController  
public class Controller {  

	... ...
  
    @GetMapping("test")  
    public TestResponse test(){  
//        return hotelMapper.selectList(null);  
        TestResponse rs = new TestResponse(true, "test", "testsuccess");  
        rs.absorbRes(hotelMapper.selectList(null));  
        return rs;  
    }

	... ...
}
```

这样我们得到的结果就显而易见了，使用Postman来测试一下。我们hotels中的表是这样的：

![[homework/Database/resources/Pasted image 20221128221953.png]]

下面是得到的响应：

```json
{
    "status": true,
    "op": "test",
    "msg": "testsuccess",
    "list": [
        {
            "location": "Harbin",
            "price": 150,
            "numRooms": 40,
            "numAvail": 40
        },
        {
            "location": "ShangHai",
            "price": 450,
            "numRooms": 200,
            "numAvail": 199
        },
        {
            "location": "Xian",
            "price": 300,
            "numRooms": 80,
            "numAvail": 80
        }
    ]
}
```

接下来，我们就可以去写下订单的操作了。其实就是对数据库进行一次insert操作，然后对其下单的飞机、巴士、旅馆进行`可用-1`的操作。首先是一个insert，在Mybatis plus中也很简单：

```java
reservationMapper.insert(rsv);
```

这个函数就能将rsv插入到表flights中。插入完了就完了吗？没有！因为数据库的完整性约束，我们需要让对应航班的可用位置减一才行。但是，我们的订单是这样的：

```txt
00013U8595
```

是`id + 预定对象的主键`的形式。因此我们需要将id给扔掉，只保留主键部分，才能去对应的表中查到我们想修改的tuple。思路也很简单：

```java
String rsvVal = rsv.getResvKey().substring(4);
```

然后我们就要使用这个rsvVal(在本例中就是`3U8595`)去修改。但是我发现，Mybatis plus提供的update接口只有这两种：

![[homework/Database/resources/Pasted image 20221128223149.png]]

而我们需要做的只是将里面的`num_avail`值-1而已。这样重新传一个对象进去，我怎么知道原来的值是多少，要不也不能减一啊！这意味着还要先查一下原来是多少，然后-1，然后构造新的对象，然后传进去。这也太麻烦了！好在，Mybatis plus保留了Mybatis原生的所有特性，所以我们可以直接使用注解SQL语句去查询。这就需要修改flightMapper这个接口了：

```java
@Mapper  
public interface FlightMapper extends BaseMapper<Flight> {  
    @Update("update flights set num_avail = num_avail - 1 where flight_num = #{fkey}")  
    public int afterResv(@Param("fkey") String fkey);  
}
```

> 这里`int`前面的public可以省略。

这条语句以及函数编写的形式和Retrofit简直太像了，所以就不解释了。有了这个接口，在Controller中就只需要这么写了：

```java
@PostMapping("reserve/flight")  
public ReservationResponse reserveFlight(@RequestBody Reservation rsv){  
    reservationMapper.insert(rsv);  
    String rsvVal = rsv.getResvKey().substring(4);  
    flightMapper.afterResv(rsvVal);  
    return new ReservationResponse(true, "reserve flight", "reserve success");  
}
```

这4条语句所做的事也就一清二楚了。那么照葫芦画瓢，我们能写出预定公交车和酒店的方法：

```java
@PostMapping("reserve/hotel")  
public ReservationResponse reserveHotel(@RequestBody Reservation rsv){  
    reservationMapper.insert(rsv);  
    String rsvVal = rsv.getResvKey().substring(4);  
    hotelMapper.afterResv(rsvVal);  
    return new ReservationResponse(true, "reserve hotel", "reserve success");  
}  
  
@PostMapping("reserve/bus")  
public ReservationResponse reserveBus(@RequestBody Reservation rsv){  
    reservationMapper.insert(rsv);  
    String rsvVal = rsv.getResvKey().substring(4);  
    busMapper.afterResv(rsvVal);  
    return new ReservationResponse(true, "reserve bus", "reserve success");  
}
```

最后就是这个查询旅行线路的功能。这个功能还是有点复杂的，我们来缕一缕：

1. 我叫SpreadZhao，我要查询所有我的旅行信息，那就是查找我的所有航班。因此需要在reservations表中查找所有cust_name是SpreadZhao的tuple，并且只需要投影出resv_key属性；
2. resv_key属性由于是`00013U8595`这种形式。因此如果有多条记录，比如我一个人买了两张机票，还都是同一架飞机，那么这两次的路程其实是一样的，不需要重复查询。因此我需要对返回的结果集合去重；
3. 去重肯定不能带着前面的id去重，所以首先要去掉id；
4. 去掉所有id之后(`00013U8595 -> 3U8595`)，这个列表中就有可能会有多个`3U8595`。因此需要对这个列表进行去重；
5. 去重之后，我就能拿到一坨String。而这一坨String中的每一个，都要去flights表中查询，查到对应tuple的from_city和ariv_city，这就是我们的旅程信息；
6. 将这些信息打包好，塞到Response中返回即可。

按着这几步，看showjourney的方法就很简单了：

```java
@GetMapping("showjourney")  
public JourneyResponse showJourney(@RequestParam("name") String name){  

	// 拿到reservations中所有人名是name，并且type是飞机的  
	LambdaQueryWrapper<Reservation> lqw = new LambdaQueryWrapper<>();  
	lqw.eq(Reservation::getCustName, name);  
	lqw.eq(Reservation::getResvType, 1);  
	lqw.select(Reservation::getResvKey);  
	List<Reservation> originRes = reservationMapper.selectList(lqw);  

	// 将Reservation列表脱出成String列表
	List<String> strRes = new ArrayList<>();  
	for(Reservation elem : originRes){  
		strRes.add(elem.getResvKey());  
	}  

	// 去掉前四位id  
	List<String> strippedRes = stripId(strRes);  

	// 剩余的表中去重  
	List<String> res = removeDuplicate(strippedRes);  

	// 构建响应，初始化journeys并且设置好人名  
	JourneyResponse journeyResponse = new JourneyResponse(true, "show journey", "show success", name);  

	// 拿res中的元素挨个遍历查找flights表  
	for(String fkey : res){  
		// 找到对应航班的tuple，提取出来去城市  
		LambdaQueryWrapper<Flight> lqwf = new LambdaQueryWrapper<>();  
		lqwf.select(Flight::getFlightNum, Flight::getFromCity, Flight::getArivCity);  
		lqwf.eq(Flight::getFlightNum, fkey);  
		Flight flightRes = flightMapper.selectOne(lqwf);  

		// 构造journey对象，添加到journeys中  
		journeyResponse.addJourney(new Journey(flightRes.getFlightNum(), flightRes.getFromCity(), flightRes.getArivCity()));  
	}  

	return journeyResponse;  
}
```

这里用到了两个方法stripId和removeDuplicate。这两个方法也在Controller中定义：

```java
private List<String> stripId(List<String> list){  
        List<String> res = new ArrayList<>();  
        for (String elem : list) {  
            res.add(elem.substring(4));  
        }  
        return res;  
    }  
  
    private List<String> removeDuplicate(List<String> list){  
        List<String> res = new ArrayList<>();  
        boolean isContain = false;  
        for(String elem : list){  
            for (String re : res) {  
                if (elem.equals(re)) {  
                    isContain = true;  
                    break;                }  
            }  
            if(!isContain){  
                res.add(elem);  
            }  
        }  
        return res;  
    }
```

stripId方法不能直接修改其中的String。**String对象在初始化的时候就已经固定，每次赋值都只是返回了一个新的String**。因此这里我们只能新建一个`List<String>`了。

做到这里，基本的功能就已经实现的差不多了。对于服务端来说，能实现一些基本的查询就足矣。我们接下来就开始做客户端。客户端