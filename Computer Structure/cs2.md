---
author: "Spread Zhao"
title: cs2
category: inter_class
description: 计算机组成与结构2课堂笔记，蒋志平老师
---

# 1. Pipe Line

举个洗衣服的例子：

![[Pasted image 20221115130320.png]]

那么如果是**纯串行**的话，就是张三洗烘熨放；李四洗烘熨放……

![[Pasted image 20221115130443.png]]

这样一共要八个小时，也太浪费了。其实，第一个人在洗完之后，洗衣机完全就可以给第二个人用了，烘干机、熨斗、晾衣架也是如此。那么我们完全可以这样：

![[Pasted image 20221115130650.png]]

**由此例子，我们能总结出流水线任务的特点**：

* 可被拆解
* 拆解的段可同时执行

当然，流水线的特点不止这些：

![[Pasted image 20221115131321.png]]

* 大量：不能好多人只做一道题，那分也没啥意思
* 可分解：比如好多人都只做洗衣服，难道还要给某个人分工只放洗衣粉？
* 重复劳动：不能让一个人一会儿干这个，一会儿又干那个
* 交错式：Concurrent和Parrallel的区别。并发和同时进行的区别。多个人不一定在一个时刻干同一件事，它们是交错进行的。
* 时间特征：

  ![[Pasted image 20221115131545.png]]
  
  我们能看到，圈起来的空档是不饱和的，也就是流水线中的人没有都全部进入工作状态；而框起来的部分就是饱和的。

![[Pasted image 20221115131930.png]]

## 1.1 Classification

流水线的分类有以下几种：

* 单功能 vs 多功能
* 静态 vs 动态
* 级别（处理机级、部件级、宏级）
* 线性 vs 非线性
* 顺序 vs 乱序
* 标量 vs 向量

接下来我们就逐一讨论它们。

**单功能，多功能**

我们看这样一个流水线：

![[Pasted image 20221115161103.png]]

这8个就是当前流水线的各个**功能段**。我们注意到，这里面不仅有加减法，还有乘法。这代表这个流水线不止能完成加减运算，还能做乘除运算。那么我们如何去实现它们呢？显然是通过不同的编程模式，**让这8个stage中的某几个以不同的方式连接起来**，就能完成不同的操作：

![[Pasted image 20221115161305.png]]

像这样能通过编程来实现不同功能的流水线就叫做多功能流水线；反之，如果只能一条道走到黑，那就是单功能流水线。

---

**静态，动态**

比如我们要算加法和乘法。静态流水线就是，先算加法，当所有的加法全算完时，才能开始算乘法。中间宁可空闲也不能提前做：

![[Pasted image 20221115161916.png|300]]

而动态流水线就能很好得利用空闲，提前让一些人去做下一步任务。这样自然也增加了控制的难度，让流水线调度变复杂。

![[Pasted image 20221115162032.png]]

还是举之前单功能多功能的例子，对于静态和动态，它们的**时空图**就是这样的：

![[Pasted image 20221115162340.png|300]]   ![[Pasted image 20221115162418.png|300]]

---

**处理机级、部件级、宏级**

我们在上学期学过，处理器执行指令就分[[cs#2.1 Overview|四步走]]，那么对于这样重复的事情，很显然用流水线可以极大地提高性能。

![[Pasted image 20221115163001.png]]

那么比如我们取到了一个浮点加法的指令，我们之前也学过，浮点的加减法非常复杂，那么肯定会分成许多步骤去执行。那么在这里又可以使用流水线来提高性能。这样就相当于大流水线(处理机级)里夹了一个小流水线(部件级)。

![[Pasted image 20221115163211.png]]

宏级日常用不到，直接给了：

![[Pasted image 20221115163345.png]]

---

**线性，非线性**

![[Pasted image 20221115163527.png]]

![[Pasted image 20221115163537.png]]

---

**顺序，乱序**

比如有下面的指令：

```c
c = a + b; // 1
e = d + c; // 2
x = y + z; // 3
```

我按着1,2,3的顺序输入，那么输出的结果还会是1,2,3吗？在回答这个问题之前，首先分析一下代码：由于第二条中的c用到了第一条中的结果，那就意味着第二条语句一定不能在第一条语句之前执行。但是第三条语句和前两条语句并没有什么关系，所以顺序和乱序的区别就在这里体现出来：

* 如果是顺序流水线，那么输出就是1,2,3；
* 如果是乱序流水线，那么输出很可能是1,3,2或者3,1,2。

这样，乱序流水线就可以让3和1或者2并行，来提高效率。

---

**标量，向量**

![[Pasted image 20221115171017.png]]

---

Concurrent vs Parallel

前者就是流水线的思想：四个人分工，在不同的时刻干不同的事。而后者是完全意义上的并行，也就是不同的人在同一时刻干的就是同一个事。而这两者完全可以叠加起来，也就是时间并行+空间并行：

![[Pasted image 20221115171354.png]]

## 1.2 流水线性能分析

### 1.2.1 Throughput

比如一个人在一段时间内完成了一些活，那么它的吞吐率就是：

$$
TP = \frac{n}{t}
$$

其中，n是有多少活，t是时间。比如一个人在100秒内做了1000个活，那吞吐率就是10。而由于有启动时间，或者中间有空档等等原因，吞吐率不一定时时刻刻都是最大的。而最大的吞吐率就叫做$TP_{max}$。那么我们可以推测出来一些信息：比如某个流水线的各个时间段相等，也就是每个stage所占的时间都是$\Delta t_0$。那么也就是说，在饱和后每经过$\Delta t_0$的时间，就会完成1个活，那么显然这个时候的最大吞吐率就是：

$$
TP_{max} = \frac{1}{\Delta t_0}
$$

而如果每个stage所占的时间不相等的话，比如下面这样：

![[Pasted image 20221115172139.png]]

显然这个最长的2，就限制了整个流水线。我们看下面的图：

![[Pasted image 20221115172309.png]]

最左下角的2可以在红圈里滑动，但是咋滑都没用，因为这个最长的2任务就限制了它运行的时间，不管你提前做还是后做，你都要等1这个人把2任务做完之后，2这个人才能做他的2任务。这样就导致了每个任务的输出间隔都变成了最长的$3\Delta t_0$，因此如果间隔不相等的话，最大吞吐率：

$$
TP_{max} = \frac{1}{max\{\Delta t_i\}}
$$

怎么解决这个问题？一个比较直观的方法是：将$3\Delta t_0$拆成三个$\Delta t_0$不就好了嘛！所以我们可以这样：

![[Pasted image 20221115172701.png]]

这种方法的问题显而易见：拆不了咋办？那也有招。我原来是让4个人干4个活，而第二个活用的时间是其他的三倍，**那我就找6个人干4个活，第二个活让三个人来干**。这样虽然进度是一样的，但是第二个活被加速了3倍，所以最终速度也是一样的。只不过这种方式的时空图不太好理解：

![[Pasted image 20221115173155.png]]

