<center><h1>Spectre & Meltdown侧信道攻击</h1></center>

## 1 Flush + Reload Attack

### 1.1 什么是侧信道攻击

简单来说，就是通过“侧面的手段”来窃取计算机隐私信息的攻击手段。虽然计算机程序写的是没问题的，但是总是可以通过其它的隐蔽手段来检测。下面是一些例子。

* 功耗检测：如果有两个分支（比如if和else），而else分支执行的过程中，它的功耗总是比if分支要高，那么可以确定，else分支是经常更容易被执行的；
* 执行时长：同上，只不过这次换成了统计执行的时长；
* CPU缓存：CPU是会使用Cache的，因为有些数据在读写的过程中会经过Cache，所以也就留下了被攻击的隐患。

### 1.2 Flush + Reload攻击手段

这里要介绍的比较简单的攻击手段，即**Flush + Reload Attack**使用的就是第三种方式。

为什么Cache会被攻击呢？根本原因是：**使用Cache访问时，耗时会显著低于不使用Cache**。因此，攻击者可以利用这一特点，对**一段Cache对应的内存**进行监控，当监控到访问速度异常的内存时，证明这段内存是被Cache加速过的，也就是被受害者访问过的内存。

如何进行攻击？这里介绍一个比较常见的方法。英特尔x86计算机有一个任意权限都可以执行的指令：`cflush`。该指令的作用就是通过给出的内存地址，来清空缓存行，并写回到内存里：[CLFLUSH — Flush Cache Line (felixcloutier.com)](https://www.felixcloutier.com/x86/clflush)。另一个指令是`rdtsc`，它类似于Java中的`System.currentTimeMillis()`方法，只不过返回的是当前CPU的时钟数。

通过以上两个指令，我们能很轻松地实现对缓存行的监控行为：

1. 将一段连续的内存对应的缓存行都清除（使用`cflush`）；
2. 等待受害者执行，并试图访问这段连续的内存；
3. 等待一段时间后，使用`rdtsc`统计这段内存的访问耗时。由于我们之前清空过缓存行，因此如果依然存在访问时间明显更快的内存，那么这段内存就是被加速的内存。

在这个过程中，由于我们能够精确控制地址，所以只要得到了被加速的内存，我们完全可以将其中的值取出来，来实现侧信道攻击。

### 1.3 有状态攻击

总结一下以上攻击的一些特点。我们能发现，这种攻击总是攻击者**提前布一个局**，等着受害者来踩坑，最后攻击者通过**状态的改变**，来获取非法信息。因此，这种攻击手段叫做有状态攻击（Stateful Attack），这种攻击总具有以下特点：

* 攻击者将系统置为已知的状态（刷新缓存行）；
* 受害者操作了系统，将状态改变；
* 攻击者重新检查系统的状态，来通过状态的改变窃取信息；

## 2 Meltdown攻击

Meltdown攻击诞生于2017年，一经发现，就让所有具有**乱序执行**功能的处理器大惊失色。而这种处理器几乎就是全部的处理器了。

### 2.1 Meltdown简介

这个漏洞的作者声称：

* Meltdown能破坏所有基于地址空间的计算机系统；
* Meltdown可以读取所有包含隐私信息（密码，密钥等）的内核态内存；
* Meltdown可以在云端读取其它进程或虚拟机的内存空间，并且不需要任何额外的权限。

### 2.2 操作系统的内存分布

我们都知道，操作系统分为内核态和用户态。所有用户态的执行，最终都会调用到内核态的代码，这个过程也就是系统调用（syscall）。这个切换的过程叫做陷入（trap）。然而，频繁地进行双态的切换势必会影响性能。因此os内核在编写的时候就采取过一系列措施。其中之一，就是**内核会将自己线性地映射到每一个进程的虚拟地址中**。这样对于进程来说，接触到内核态就会更加容易一些。

然而，如果我们企图在用户态直接访问内核中的一些信息时，通常会发生段错误。下图是我初学c语言的时候遇到的一个问题：

![[Article/story/resources/Pasted image 20221101162035.png]]

在第11行发生了段错误。根本原因是，p是一个地址，它指向了字符串常量`abcde`。然而，这个字符串是存在于程序的数据段常量池中，属于非法区域。所以我们不能够对其进行写操作，只能进行读操作。

对于内核的访问，更是如此，甚至很多信息是我们读都不能读的。具体的原理的话，就是内存有一个US（User/Supervisor）标识为，来控制用户/内核对这段内存的访问权限。

### 2.3 Meltdown的原理

看下面的代码：

```c
*(volatile char*) 0;
array[84 * 4096] = 0;
```

第一句是在访问0号地址，毫无疑问会引发段错误。所以，第二行其实是不会执行到的。理想情况是这样。但是，如果我们依然采用Flush + Reload的方式来探测array这段内存的访问耗时的话，可以观测到依然有一些内存被加速了。

