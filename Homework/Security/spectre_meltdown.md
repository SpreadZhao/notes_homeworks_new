<center><h1>Spectre & Meltdown侧信道攻击</h1></center>

## 1 Flush + Reload Attack

### 1.1 什么是侧信道攻击

简单来说，就是通过“侧面的手段”来窃取计算机隐私信息的攻击手段。虽然计算机程序写的是没问题的，但是总是可以通过其它的隐蔽手段来检测。下面是一些例子。

* 功耗检测：如果有两个分支（比如if和else），而else分支执行的过程中，它的功耗总是比if分支要高，那么可以确定，else分支是经常更容易被执行的；
* 执行时长：同上，只不过这次换成了统计执行的时长；
* CPU缓存：CPU是会使用Cache的，因为有些数据在读写的过程中会经过Cache，所以也就留下了被攻击的隐患。

### 1.2 Flush + Reload攻击手段

这里要介绍的比较简单的攻击手段，即**Flush + Reload Attack**使用的就是第三种方式。

为什么Cache会被攻击呢？根本原因是：**使用Cache访问时，耗时会显著低于不使用Cache**。因此，攻击者可以利用这一特点，对**一段Cache对应的内存**进行监控，当监控到访问速度异常的内存时，证明这段内存是被Cache加速过的，也就是被受害者访问过的内存。

如何进行攻击？这里介绍一个比较常见的方法。英特尔x86计算机有一个任意权限都可以执行的指令：`cflush`。该指令的作用就是通过给出的内存地址，来清空缓存行，并写回到内存里：[CLFLUSH — Flush Cache Line (felixcloutier.com)](https://www.felixcloutier.com/x86/clflush)。另一个指令是`rdtsc`，它类似于Java中的`System.currentTimeMillis()`方法，只不过返回的是当前CPU的时钟数。

通过以上两个指令，我们能很轻松地实现对缓存行的监控行为：

1. 将一段连续的内存对应的缓存行都清除（使用`cflush`）；
2. 等待受害者执行，并试图访问这段连续的内存；
3. 等待一段时间后，使用`rdtsc`统计这段内存的访问耗时。由于我们之前清空过缓存行，因此如果依然存在访问时间明显更快的内存，那么这段内存就是被加速的内存。

在这个过程中，由于我们能够精确控制地址，所以只要得到了被加速的内存，我们完全可以将其中的值取出来，来实现侧信道攻击。

### 1.3 有状态攻击

总结一下以上攻击的一些特点。我们能发现，这种攻击总是攻击者**提前布一个局**，等着受害者来踩坑，最后攻击者通过**状态的改变**，来获取非法信息。因此，这种攻击手段叫做有状态攻击（Stateful Attack），这种攻击总具有以下特点：

* 攻击者将系统置为已知的状态（刷新缓存行）；
* 受害者操作了系统，将状态改变；
* 攻击者重新检查系统的状态，来通过状态的改变窃取信息；

## 2 Meltdown攻击

Meltdown攻击诞生于2017年，一经发现，就让所有具有**乱序执行**功能的处理器大惊失色。而这种处理器几乎就是全部的处理器了。

### 2.1 Meltdown简介

这个漏洞的作者声称：

* Meltdown能破坏所有基于地址空间的计算机系统；
* Meltdown可以读取所有包含隐私信息（密码，密钥等）的内核态内存；
* Meltdown可以在云端读取其它进程或虚拟机的内存空间，并且不需要任何额外的权限。

### 2.2 操作系统的内存分布

我们都知道，操作系统分为内核态和用户态。所有用户态的执行，最终都会调用到内核态的代码，这个过程也就是系统调用（syscall）。这个切换的过程叫做陷入（trap）。然而，频繁地进行双态的切换势必会影响性能。因此os内核在编写的时候就采取过一系列措施。其中之一，就是**内核会将自己线性地映射到每一个进程的虚拟地址中**。这样对于进程来说，接触到内核态就会更加容易一些。

然而，如果我们企图在用户态直接访问内核中的一些信息时，通常会发生段错误。下图是我初学c语言的时候遇到的一个问题：

![[Article/story/resources/Pasted image 20221101162035.png]]

在第11行发生了段错误。根本原因是，p是一个地址，它指向了字符串常量`abcde`。然而，这个字符串是存在于程序的数据段常量池中，属于非法区域。所以我们不能够对其进行写操作，只能进行读操作。

对于内核的访问，更是如此，甚至很多信息是我们读都不能读的。具体的原理的话，就是内存有一个US（User/Supervisor）标识为，来控制用户/内核对这段内存的访问权限。

### 2.3 Meltdown的原理

看下面的代码：

```c
*(volatile char*) 0;
array[84 * 4096] = 0;
```

第一句是在访问0号地址，毫无疑问会引发段错误。所以，第二行其实是不会执行到的。理想情况是这样。但是，如果我们依然采用Flush + Reload的方式来探测array这段内存的访问耗时的话，可以观测到依然有一些内存被加速了。

这就是Meltdown能诞生的最大原因：**即使是不会执行的代码，实际上也可能被执行过**！正是因为计算机的乱序执行，才使得这种本来我们看不到的数据有了被看到的机会。

既然如此，有没有什么办法能让我们看到这个被执行的代码的结果呢？其实，最大的障碍就是段错误会直接导致程序进程结束，那么对应的内存会被立刻收回，再去操作这些内存就没什么意义了。所以我们要做的事情就是，**在这个错误发生的时候，依然能够维持住现场**。

具体的方式，有使用POSIX的Singal Handler。比如SIGSEGV信号，这个就是发生段错误时内核会抛给我们的信号。我们只需要钩住这个信号，拦截住其中的中断处理程序，就能够在其中进行修改，让这个现场持续下去。

在修改的中断处理程序中，我们就能够通过Flush + Reload方法来检测那段被访问过的内存谁被加速了，从而判断出那个不能被我们访问到的信息。

### 2.4 Meltdown攻击的执行过程

下面来举一个例子。假设有一个被内核加密的值，存在变量`secret`中，它的地址是`0xfff12345`。如果我们试图在用户态进程中直接访问这个内存，会发生段错误：

```c
int secret = (int)(*0xfff12345);  // 段错误
printf("%d", secret);
```

这里的第二行是执行不到的，即使执行到了，我们也没有什么手段将这里面的值给取出来。

然而，如果将第二行换成这样：

```c
int secret = (int)(*0xfff12345);  // 段错误
int array[secret * 4096] = 0;
```

这句话的本意是在虚拟内存中开辟一块secret * 4096个字节大小的空间，然后将它们都赋值成0。如果由于乱序执行的是这句话，那么意义就不一样了：secret不但被访问了，还被应用了。从0号地址，**到secret * 4096号地址**，作为一个新的区间。

接下来只需要看，在这个过程中，哪一段内存被加速了，而被加速的内存的地址就是我们想要的数据。

## 3 Spectre攻击

### 3.1 分支预测

什么是预测？就是赌！

![[Lecture Notes/Computer Structure/resources/Pasted image 20221119201917.png]]

看如下代码：

```c
if (compare()) {
	...
} else {
	...
}
```

理论上，**else分支是更快的**。原因就是当翻译为汇编之后，if分支对应的语句就是一句`jmp`，也就是会跳到别的地方去执行，而不挺跳直接向下继续执行往往是更快的。

那么我们就可以采取这种策略：运行前就规定好，每次我都赌这个程序不会跳转，只会继续执行(或者反之)。由于是提前规定好，所以这种方法叫做**静态预测分支**。

另外，静态预测分支还有其他的方法，比如由程序员去告诉编译器我跳的概率。在新版本c标准中，会有大量的`likely`或者`unlikely`标志(尤其是在linux kernel中，我在做qemu的时候也有体会)。这些标志就是用来告诉编译器翻译的时候就尽可能按着跳转或者不跳转去翻译，来提高性能。

总之，**静态分支预测的策略就是让编译器翻译出来的代码尽可能都是不会跳转的**。比如：

![[Lecture Notes/Computer Structure/resources/Pasted image 20221119202643.png]]

> a中基本上循环执行的时候每次都会提前去取**再后面**的指令，那相当于不断地白干活；而b中只有最后一次跳的时候才会取**循环体**中这些本来不会被执行的代码，只会错一次。

---

接下来就是相对应的**动态分支预测**了，这部分涉及到[[Lecture Notes/Compile/cp#3.3 Finite Automata|自动机]]的知识。动态的思想就是，在每个跳转的位置都打上一个标记，这个标记其实是一个表，**每次运行到这里时都先根据表中的信息去决定跳不跳**。首先是跳转的位置，比如一个循环：

```asm
	mov cx, 100
flag:
	mov ax, 1
	add ax, 2
	loop flag
```

`loop flag`就是一个跳转的位置，每当程序运行到这里时，都要去确定它到底要不要跳。如果跳就回到`flag`；如果不跳就继续往下执行。

接下来，我们用一个bit去实现动态分支预测。

* 首先规定：0表示不跳，1表示跳。如果我们一开始猜测所有的跳转位置都是不跳的话，那这个bit初值就是0。
* 当第一次运行到这里时，很显然是要跳的，这代表**我猜错了**，那么我就要把这个bit改成1并跳转。
* 之后运行的时候每次都会跳，也每次都是1，代表每次我都猜对了。这个时候每次都会对`mov ax, 1`和`add ax, 2`这两条指令**提前做取值译码之类的操作**。
* 只有最后一次要退出循环的时候才又错了，这个时候我不跳了，要继续往下执行了，那最后就将这个bit还原回0。

那么我们之前说的表是什么呢？一个有效位(这个标志是否有效)、这个标志本身(可以是地址或者其他的)、还有上面说的这个bit就是表中的每一项了，这也叫做**1位跳转历史表**：

![[Lecture Notes/Computer Structure/resources/Pasted image 20221119204537.png]]

由此我们也能画出上面过程的自动机：

![[Lecture Notes/Computer Structure/resources/Drawing 2022-11-19 20.46.01.excalidraw.png]]

除了1位的，我们还有2位的。这里首先给出4种状态的含义：

state bit | meaning
-- | --
00 | 强烈认为不会跳
01 | 我还是认为不会跳，但是有点动摇了
10 | 我认为会跳，但是也有点动摇
11 | 我强烈认为会跳

当处于00或者11时，都有一次猜错的机会。也就是虽然我猜错了，但是它还有可能是这样，所以我下次还不长记性。只有我下次又猜错了，我才知道我真的错了。

当处于01时，表示我认为不会跳，但是我有点动摇。这个时候如果下次真就是不会跳，那表示我的猜测还是不错的嘛！那我就变成强烈认为不会跳；而如果我猜错了，跳了，那我就变成墙头草，变成11，坚信认为会跳。处于10时的操作类似。那么根据这些，我们就能画出2位的自动机：

![[Lecture Notes/Computer Structure/resources/Drawing 2022-11-19 20.54.34.excalidraw.png]]

### 3.2 Spectre简介

和Meltdown攻击Cache不同，Spectre漏洞攻击的是CPU的分支预测模块。那么，我们需要了解，为什么分支预测会导致秘密泄露。

现在假设存在这样的一段代码：

```c
if (x < array1_size)
	y = array2[array1[x] * 512];
```

如果x小于array1的长度，就去访问array1。这个很合理对吧！但是由于之前说的分支预测，就可能有这样的情况：如果这段代码已经被执行过很多次，而每一次if判断都是成立的。那么CPU在下一次执行到这里的时候，**就会预测此次的if判断也是true，不管我x真实的值到底是什么**。因此，即使x超过了array1_size，那么if里面的代码实际上也是会被执行一遍的。

现在假设，array1_size为8，那么array1就是一个从0号到7号的区域。再假设，如果从8号开始紧跟着的就是一个不应该泄露的secret，那么如果我访问`array1[x]`，x=8的话，虽然理论上不让访问，但是由于分支预测，这里的代码也是会被提前执行的。这个时候**secret就被取出来并且执行了**！

执行出来的结果，就被存到了array2中。我们依然使用Flush + Reload手段来对array2进行捕获，就能够从中拿到我们想要的东西！

### 3.3 Spectre攻击的多种形态

Spectre漏洞以其对CPU分支预测模块的利用而闻名，它采用一种巧妙的方式来导致秘密信息泄露。上述提到的情景只是其中一种，实际上，Spectre攻击有多种形态，其中包括Variant 1（Bounds Check Bypass）和Variant 2（Branch Target Injection）等。

 * Variant 1: 边界检查绕过

Variant 1利用了类似上述代码片段的边界检查条件。通过恶意利用分支预测，攻击者可以使得在正常逻辑中不应被执行的代码被提前执行。这使得攻击者能够访问受保护的内存区域，导致秘密信息泄露。

* Variant 2: 分支目标注入

Variant 2利用了分支目标的注入，攻击者通过改变分支预测的目标地址来执行恶意代码。这种攻击形式使得攻击者能够在受害者进程的地址空间中执行恶意代码，同样导致敏感信息的泄露。

* 针对内核的Spectre攻击

除了用户空间的攻击，Spectre漏洞也可以被用于针对操作系统内核的攻击。攻击者可以通过Spectre漏洞，绕过内核的隔离，访问内核空间的敏感信息。

### 3.4 如何预防Spectre攻击

* 更新操作系统：我之前在升级操作系统的时候，就经常能看到：Side Channel的字样。无论是Windows，Mac，Android，甚至是虚拟机厂商，都一直在寻找一个能完美防护这种攻击的措施。无奈的是，似乎除了牺牲绝大部分的性能之外，没有什么好的办法彻底杜绝这种攻击。于是只能针对某些特定的场景去做优化，打上一些补丁。这也就是我们的操作系统在升级的时候有可能的变化。
* 使用硬件隔离：硬件隔离技术，如Intel的SGX（Software Guard Extensions），可以帮助隔离关键代码和数据，防止它们受到Spectre攻击的影响。
* 修改代码：开发人员可以通过修改代码，采用一些防范措施，如插入随机延迟、使用条件无关的代码，来降低Spectre攻击的风险。
* 浏览器和运行时的防护：浏览器和运行时环境可以实施一些防范措施，如沙箱隔离、禁用某些指令序列等，以减轻通过恶意网页进行的Spectre攻击。

综合来看，对抗Spectre攻击需要全方位的安全措施，包括硬件、操作系统、应用程序和代码层面的防护。只有综合运用这些措施，才能更有效地减缓Spectre漏洞可能带来的潜在威胁。

## 4 总结和发展

Meltdown是一种利用现代处理器上的乱序执行和侧信道的新型基于软件的攻击，可从非特权用户空间程序中读取任意内核内存。Meltdown无需任何软件漏洞，并且独立于操作系统，使得攻击者能够以每秒高达503 KB的速度读取云中其他进程或虚拟机的敏感数据，影响数百万设备。原本旨在防御KASLR侧信道攻击的对策KAISER，对Meltdown的防御效果并不明显。KAISER需要在每个操作系统上部署作为一种短期解决方案，直到Meltdown在硬件上得到修复，以防止对Meltdown的大规模利用。

KAISER（Kernel Address Isolation to have Side-channels Efficiently Removed）是一种针对侧信道攻击的对策，最初设计用于防御KASLR（Kernel Address Space Layout Randomization）攻击。KASLR是一种安全机制，通过随机化内核地址空间的布局，使得攻击者更难以利用内存地址信息来进行攻击。但是，KAISER却并没有完全地消除Meltdown的攻击，目前Linux内核以及Windows内核都在加深对于KAISER和Meltdown之间碰撞的研究，以将Meltdown所带来的危害不断削减。

我个人认为，Sepctre的出现是更加令计算机世界崩塌的一件事情。因为Spectre打破了传统人对于计算机指令的过度依赖：“只要不会走到，就一定不会执行”。然而， 这个漏洞也确确实实是由一些看似正常且合理的因素导致的。我们希望提升计算机的性能，于是引入了分支预测，引入了乱序执行，希望计算机的流水线能利用率越高越好。但是这个过程中也带来了不可估量的风险。

软件安全的基础在于硬件和软件开发者对于 CPU 实现从计算中暴露哪些信息。因此，尽管某些针对Spectre漏洞的对策可能有助于在短期内限制实际的利用，但它们只是应急措施，因为通常没有正式的体系结构保证来确认任何特定代码结构在今天的处理器上是否安全，更不用说未来的设计。长期解决方案需要根本性地改变指令集架构，并且安全性和性能之间存在权衡。处理器、编译器、设备驱动程序、操作系统以及许多其他关键组件都经历了复杂优化的层层叠加，引入了安全风险。随着不安全性带来的成本上升，这些设计选择需要重新审视。在许多情况下，可能需要采用为安全性进行优化的替代实现。