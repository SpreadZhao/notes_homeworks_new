# 演讲稿

## 第一题

首先，我们为了规范，在数据段里定义了一些宏常量和与ui交互有关的字符串常量。比如，把`null`定义为0，还有`Windows`和`Linux`的换行符，还有字符串的结束标志等等。然后最重要的是一个输入的字节集合，其中第一个字节是允许输入的最大字符串的长度(包括字符串结束标志)，第二个字节是用来存储实际在程序运行时用户输入的字符串长度。之后的6个字节就用来存储用户输入的分数(以字符串的形式)

```c++
char* p = new char[6];
*p = 6;
*(p + 1) = len;
```

程序开始运行的时候，主要就是以下几个步骤：

1. 清屏
2. 打印ui_score
3. 打印score
4.  从键盘中读数，并保存到input_buf中
5.  判断输入的数字是小数，负数，非法
6. 得到我要输入的数字(string -> int)
7. 根据数字和评级的边界的比较来确定成绩并输出

这是我们程序运行的结果：首先打印出来版本信息，然后输出一个`score`然后程序挂起，等待用户输入分数。比如说，我输入一个xxx，运行完之后就会打印出成绩

## 第二题

第二题首先我们来看一下程序，输入的两个数都是一位符号，用源码表示，4bit数据位的数字。在运算的时候，符号位采用两位，这里我们用10个字节来模拟这两个用于存放被乘数和乘数的寄存器，前两个字节是符号位，之后四位是被乘数的数字位，最后是乘数的数字位。首先将被乘数置零，判断乘数的最后一位是0还是1，如果是：

* 0，则被乘数加上0000后右移
* 1，则被乘数加上本身后右移

不断循环下去，直到所有的乘数都被挤走后，后面的8个字节就是最终的结果。而符号位在最后单独进行异或运算

## 第三题

数据段首先是n和i，即斐波那契数列的第一个数和第二个数，m是生成的数列的个数。最终的结果存在`result`里面，然后转成`bcd`码，最后转换成`string`输出。还有一些用于判断出错的字符。具体的过程如下：

1. 清屏

2. 把所需要生成的`fbnq`个数输入至`input_buf`中

3. 判断输入（为q退出/不是q则判断是不是数字的合法输入）

4. 调用`get_value`将输入的字符转化通过`div_n`（由于是十进制，所以用乘10进行移位）转化为对应的数字后存入m

5. 开始生成`fbnq`数列：

   1. 先将程序定义好的两个起始浮点数压入浮点栈,先行输出初始的初始的两个数（由于要转化成小数点后有四位的浮点数，所以先乘10000再把小数点放到相应位置）

   2. 从第三个数开始进行前两个数的累加，结果放至result，但此时result不是所需格式，通过同上的转化后吧结果放入Result_bcd，但如果超出了就放入预先设定的`nan`退出累加

6. 把`result_bcd`转化到事先设定的string中，打印输出string

## 第五题

首先一个比较重要的是一些双字，这些双字是用来判断排序的过程中是否发生了错误，如果发生了，那通过检测这些值是不是我定义的初始值就能判断是否发生错误；同时也是用来保存排序完成的结果的空间。另外还有一个`div_n`用来计算的时候把字符串转换成整数，因为转换的过程就是不断把你这个数左移，左移的过程就是不断地乘10，输入的内容的空间定义的还是和第一题一样。

程序运行的步骤大概就是：

1. 清屏并移动光标到左上角
2. 打印`title`
3. 依次输入10个数字到`input_buf`中
4. 依次对输入的数字进行检验(越界，非法等)
5. 依次将输入的数字转换成对应的十进制数字
6. 将转换好的10个数字进行冒泡排序
7. 每一次快速排序完成后，会选出最大的数，排序完成后把排好序的数字放到`arr`里
8. 遍历`arr`并输出

## 第四题

第四题的思路和第五题其实一模一样，就是全部排序完，取里面第二大的数

